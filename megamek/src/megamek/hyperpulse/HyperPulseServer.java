/*
 * Copyright (C) 2025 The MegaMek Team. All Rights Reserved.
 *
 * This file is part of MegaMek.
 *
 * MegaMek is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License (GPL),
 * version 3 or (at your option) any later version,
 * as published by the Free Software Foundation.
 *
 * MegaMek is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty
 * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * A copy of the GPL should have been included with this project;
 * if not, see <https://www.gnu.org/licenses/>.
 *
 * NOTICE: The MegaMek organization is a non-profit group of volunteers
 * creating free software for the BattleTech community.
 *
 * MechWarrior, BattleMech, `Mech and AeroTech are registered trademarks
 * of The Topps Company, Inc. All Rights Reserved.
 *
 * Catalyst Game Labs and the Catalyst Game Labs logo are trademarks of
 * InMediaRes Productions, LLC.
 */
package megamek.hyperpulse;

import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Consumer;

import megamek.common.annotations.Nullable;
import megamek.common.net.connections.AbstractConnection;
import megamek.common.net.factories.ConnectionFactory;
import megamek.common.net.listeners.ConnectionListener;
import megamek.logging.MMLogger;
import megamek.server.ConnectionHandler;

/**
 * <p>The <code>HyperPulseServer</code> listens for connections for both hosts and clients.  It's meant to be
 * used by a dedicated public server that will allow hosts and clients to connect without having the dedicated server
 * host a {@link megamek.server.Server Server} and {@link megamek.common.game.Game Game} object.  This class will
 * maintain relationships between host and client connections through a privately shared unique host ID generated by the
 * host connection.  Game packets are then brokered by the <code>HyperPulseServer</code> between the clients and
 * host.</p>
 *
 * <p>This enables a player to host a game privately without configuring port forwarding or firewall
 * rules on their local machine at the expense of an extra step of connecting to this hosted
 * <code>HyperPulseServer</code>.</p>
 *
 * <p>When client data packets are received, they will be forwarded through the associated host's
 * connection wrapped in a client info envelope that will be used by the host locally to interact with the locally
 * hosted server.  {@link megamek.server.Server Server} packets sent through the host connection will be unpacked here
 * and dispersed back to the associated client as a {@link megamek.common.net.packets.Packet Packet}</p>
 *
 * <p>A single <code>HyperPulseServer</code> dedicated server may be able to handle multiple game
 * sessions from multiple hosts and their clients simultaneously without too much interference or performance issues
 * between them depending on game size and network resources. (experimental)</p>
 */
public class HyperPulseServer implements Runnable {

    private static final MMLogger logger = MMLogger.create(HyperPulseServer.class);
    public static final int DEFAULT_LISTEN_PORT = 2348;
    public static final int PORT_UNDEFINED = -1;
    private final ServerSocket serverSocket;
    private Thread run_thread = null;

    // Used to ensure only one thread at a time is accessing this particular instance of the server.
    private final Object serverLock = new Object();
    private int connectionCounter = 0;
    private final ConnectionListener connectionListener = new HyperPulseConnectionListener(this);
    private static HyperPulseServer serverInstance = null;
    final Map<Integer, ConnectionHandler> connectionHandlers = new ConcurrentHashMap<>();
    private final List<AbstractConnection> connections = new CopyOnWriteArrayList<>();

    /**
     * Construct a new HyperpulseServer object given the provided port number. This sets up the
     * <code>ServerSocket</code> and kicks off a listener thread that waits on incoming connections.
     *
     * @param serverSocket - {@link ServerSocket} configured to listen and accept connections on the configured port. If
     *                     the passed in is null, a default {@link ServerSocket} will be created to listen on the
     *                     default port 2346
     */
    public HyperPulseServer(ServerSocket serverSocket) {
        serverInstance = this;
        this.serverSocket = serverSocket;

        logLocalHostDetails(logger::info);
    }

    /**
     * Starts the main thread to listen for new connections in the background.
     */
    public void startProcessingConnections() {
        // Fully initialized, now accept connections
        run_thread = new Thread(this, "ConnectServer Connection Listener");
        run_thread.start();
    }

    /**
     * Listen on the Hyperpulse's designated port for incoming connections from external clients or hosts.
     */
    @Override
    public void run() {
        logger.info("Connector: listening for connection hosts and clients...");

        while (run_thread == Thread.currentThread()) {
            try {
                // Separate creation of a new Socket processing it for unit testing.
                // ServerSocket::accept() is a blocking call. Only returns when a new
                // connection is made.
                processNewClientConnection(serverSocket.accept());
            } catch (IOException e) {
                logger.error(e);
            }
        }
    }

    /**
     * Respond to an incoming connection and set it up to process traffic.  This will be called once for each incoming
     * connection.
     *
     * @param socket - A new connection has been detected this is the socket for the new connection.  If the passed in
     *               socket is null, the call will be ignored.
     */
    protected void processNewClientConnection(Socket socket) {
        if (socket == null) {
            return;
        }

        synchronized (serverLock) {
            try {
                int id = getFreeConnectionId();
                logger.info("CS: accepting player connection #{}...", id);

                ConnectionHandler ch = launchConnectionHandlerThread(createServerConnection(socket, id));

                connectionHandlers.put(id, ch);
            } catch (Exception e) {
                //catch all here so we don't throw outside the synchronized block.
                logger.error(e);
            }
        }
    }

    private AbstractConnection createServerConnection(Socket socket, int connectionId) {
        AbstractConnection connection = ConnectionFactory.getInstance().createServerConnection(socket, connectionId);
        connection.addConnectionListener(connectionListener);
        connection.open();
        connections.add(connection);
        return connection;
    }

    private ConnectionHandler launchConnectionHandlerThread(AbstractConnection connection) {
        ConnectionHandler connectionHandler = new ConnectionHandler(connection);
        Thread newConnThread = new Thread(connectionHandler, "Connection " + connection.getId());
        newConnThread.start();
        return connectionHandler;
    }

    /**
     * @return the current server instance. This may be null if a server has not been started
     */
    public static @Nullable HyperPulseServer getServerInstance() {
        return serverInstance;
    }

    /**
     * Get the next unused connection ID. Each client or host that connects to the
     * <code>ConnectServer</code> will be assigned a unique ID.
     *
     * @return - integer server unique connection ID for the ConnectServer connection.
     */
    private int getFreeConnectionId() {
        return connectionCounter++;
    }

    /**
     * Grab the local host name and configured Internet address(es) and write them to a log using the passed in
     * {@link Consumer} function.
     *
     * @param m - a message passed to the {@link Consumer} to be processed.
     *
     */
    public void logLocalHostDetails(Consumer<String> m) {
        try {
            String message;

            String host = InetAddress.getLocalHost().getHostName();
            message = String.format("s: hostname = '%s' port = %d", host, getLocalPort());
            m.accept(message);

            InetAddress[] addresses = InetAddress.getAllByName(host);
            for (InetAddress address : addresses) {
                message = String.format("s: hosting on address = %s", address.getHostAddress());
                m.accept(message);
            }
        } catch (Exception e) {
            m.accept("ERROR " + e + ": Ignore Exception.");
        }
    }

    /**
     * Returns the local port the <code>HyperPulseServer</code> is listening to on.
     *
     * @return - Integer: listening port number.  Returns -1 if the actual listening port cannot be determined.
     */
    public int getLocalPort() {
        if (serverSocket != null) {
            return serverSocket.getLocalPort();
        }

        return PORT_UNDEFINED;
    }
}
